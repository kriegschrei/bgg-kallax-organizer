import {
  getCollection,
  setCollection,
  getGame,
  setGame,
  getVersion,
  setVersion,
  hashData,
  extractCollectionData,
  extractGameData,
  extractVersionData,
} from '../../cache.js';
import {
  buildCorrectionUrl,
  buildGameCorrectionUrl,
  buildVersionsUrl,
  COLLECTION_STATUS_KEYS,
  extractBaseGameId,
  extractVersionId,
  extractVersionLabelFromName,
  isStatusActive,
} from '../utils/gameUtils.js';
import {
  calculateStatsSummary,
  getOversizedStuffedGames,
  packGamesIntoCubes,
} from './packingService.js';
import {
  bggApiRequest,
  parseBggXml,
  processGameItem,
  findDimensionsFromVersions,
} from './bggService.js';
import { BGG_API_BASE, BGG_API_TOKEN } from './configService.js';

export const mapStatusesToIncludeExclude = (statuses = {}) => {
  const includeStatuses = [];
  const excludeStatuses = [];

  COLLECTION_STATUS_KEYS.forEach((key) => {
    const value = statuses[key];
    if (value === 'include') {
      includeStatuses.push(key);
    } else if (value === 'exclude') {
      excludeStatuses.push(key);
    }
  });

  if (includeStatuses.length === 0) {
    includeStatuses.push('own');
  }

  return { includeStatuses, excludeStatuses };
};

const getPrioritiesFromSort = (sort = []) =>
  Array.isArray(sort)
    ? sort
        .filter((rule) => rule?.field)
        .map((rule) => ({
          field: rule.field,
          order: rule.order === 'desc' ? 'desc' : 'asc',
        }))
    : [];

const normalizeBooleanFlag = (value, defaultValue = false) =>
  typeof value === 'boolean' ? value : defaultValue;

export const processGamesRequest = async ({
  payload,
  username,
  requestId,
  onProgress,
}) => {
  const progress =
    typeof onProgress === 'function'
      ? onProgress
      : () => {};
  if (!BGG_API_TOKEN) {
    console.error('‚ùå BGG API token not configured');
    progress(requestId, 'Error: BGG API token not configured', { error: true });
    throw new Error('BGG API token not configured');
  }

  const { includeStatuses, excludeStatuses } = mapStatusesToIncludeExclude(
    payload.statuses,
  );

  const stacking = payload.stacking || 'horizontal';
  const lockRotationFlag = normalizeBooleanFlag(payload.lockRotation);
  const optimizeSpaceFlag = normalizeBooleanFlag(payload.optimizeSpace);
  const respectSortOrderFlag = normalizeBooleanFlag(payload.respectSortOrder);
  const fitOversizedFlag = normalizeBooleanFlag(payload.fitOversized);
  const groupExpansionsFlag = normalizeBooleanFlag(payload.groupExpansions);
  const groupSeriesFlag = normalizeBooleanFlag(payload.groupSeries);
  const includeExpansionsFlag = normalizeBooleanFlag(payload.includeExpansions);
  const bypassVersionWarning = normalizeBooleanFlag(payload.bypassVersionWarning);

  const sortRules = getPrioritiesFromSort(payload.sort);

  const overridesPayload = payload.overrides || {};

  console.log('üéÆ Processing games for user:', username);
  console.log('   Options:', {
    includeStatuses,
    excludeStatuses,
    includeExpansions: includeExpansionsFlag,
    stacking,
    lockRotation: lockRotationFlag,
    optimizeSpace: optimizeSpaceFlag,
    fitOversized: fitOversizedFlag,
    groupExpansions: groupExpansionsFlag,
    groupSeries: groupSeriesFlag,
  });

  progress(requestId, 'Starting to process your collection...', { step: 'init' });

  const collectionParams = new URLSearchParams({
    username,
    stats: 1,
    version: 1,
  });

  includeStatuses.forEach((statusKey) => {
    collectionParams.append(statusKey, 1);
  });

  const collectionUrl = `${BGG_API_BASE}/collection?${collectionParams.toString()}`;
  const includeKeySegment = includeStatuses.slice().sort().join('|') || 'none';
  const collectionKey = `user:${username}:includes:${includeKeySegment}:expansions:${includeExpansionsFlag}`;

  let collection;
  let collectionResponse;
  let collectionHash = null;
  let cachedCollection = null;

  console.log('üì• Checking cache for collection...');
  progress(requestId, 'Fetching your collection from BoardGameGeek...', {
    step: 'collection',
  });

  let retries = 0;
  const maxRetries = 5;

  while (retries < maxRetries) {
    collectionResponse = await bggApiRequest(collectionUrl, {
      headers: {
        Authorization: `Bearer ${BGG_API_TOKEN}`,
        Accept: 'application/xml',
      },
      validateStatus: (status) => status === 200 || status === 202,
    });

    if (collectionResponse.status === 202) {
      console.log(
        `   ‚è≥ Collection queued (202), retrying in ${2 + retries} seconds... (attempt ${
          retries + 1
        }/${maxRetries})`,
      );
      progress(requestId, `Collection is being prepared, waiting ${2 + retries} seconds...`, {
        step: 'collection',
        retry: retries + 1,
      });
      await new Promise((resolve) => setTimeout(resolve, (2 + retries) * 1000));
      retries += 1;
    } else {
      console.log('   ‚úÖ Collection ready (200)');
      break;
    }
  }

  if (collectionResponse.status === 202) {
    progress(requestId, 'Collection generation timed out', { error: true });
    throw new Error('Collection generation timed out. Please try again in a few moments.');
  }

  collectionHash = hashData(collectionResponse.data);
  cachedCollection = getCollection(collectionKey, collectionHash);

  if (cachedCollection) {
    console.log('   ‚úÖ Using cached collection data');
    progress(requestId, 'Using cached collection data', {
      step: 'collection',
      cached: true,
    });
    collection = await parseBggXml(collectionResponse.data);
  } else {
    console.log('   üì• Collection not in cache or changed, parsing and caching...');
    progress(requestId, 'Processing collection data...', {
      step: 'collection',
      cached: false,
    });
    collection = await parseBggXml(collectionResponse.data);
    const collectionData = extractCollectionData(collection);
    setCollection(collectionKey, collectionHash, collectionData);
  }

  if (!collection.items || !collection.items.item) {
    console.warn('‚ö†Ô∏è  No items in collection');
    return {
      cubes: [],
      totalGames: 0,
      message: 'No games were found in the BoardGameGeek collection for this username.',
    };
  }

  let items = Array.isArray(collection.items.item)
    ? collection.items.item
    : [collection.items.item];

  console.log(`   Found ${items.length} items in collection`);
  progress(requestId, `Found ${items.length} games in your collection`, {
    step: 'collection',
    count: items.length,
  });

  items = items.filter((item) => {
    const statusAttributes = item.status?.[0]?.$ || {};

    const matchesExclude = excludeStatuses.some((statusKey) =>
      isStatusActive(statusAttributes[statusKey]),
    );
    if (matchesExclude) {
      return false;
    }

    const matchesInclude = includeStatuses.some((statusKey) =>
      isStatusActive(statusAttributes[statusKey]),
    );
    return matchesInclude;
  });

  if (items.length === 0) {
    progress(requestId, 'No games matched the selected collection filters.', {
      step: 'collection',
      count: 0,
    });
    return {
      cubes: [],
      totalGames: 0,
      message: 'No games matched the selected collection filters.',
    };
  }

  const missingVersionGames = new Map();

  if (!includeExpansionsFlag) {
    items = items.filter((item) => {
      const subtype = item.$.subtype;

      if (subtype === 'boardgameexpansion') {
        return false;
      }

      const categories = item.link || [];
      const hasExpansionCategory = categories.some((link) => {
        const type = link.$.type;
        const value = link.$.value;
        return (
          (type === 'boardgamecategory' && value === 'Expansion for Base-game') ||
          (type === 'boardgamefamily' && value?.includes('Expansion'))
        );
      });

      if (hasExpansionCategory) {
        console.log(
          `   ‚Üí Filtering expansion by category: ${item.name?.[0]?._ || item.name?.[0]}`,
        );
        return false;
      }

      return true;
    });
  }

  const seenGameVersions = new Map();
  const duplicatesRemoved = [];

  items = items.filter((item) => {
    const gameId = item.$.objectid;
    const gameName = item.name?.[0]?._ || item.name?.[0] || `ID:${gameId}`;
    const versionId = item.version?.[0]?.item?.[0]?.$?.id || 'no-version';

    if (!seenGameVersions.has(gameId)) {
      seenGameVersions.set(gameId, new Set());
    }

    const versions = seenGameVersions.get(gameId);

    if (versions.has(versionId)) {
      duplicatesRemoved.push(`${gameName} (${versionId})`);
      return false;
    }

    versions.add(versionId);
    return true;
  });

  if (duplicatesRemoved.length > 0) {
    console.log(`   ‚Üí Removed ${duplicatesRemoved.length} duplicate(s)`);
  }

  if (items.length === 0) {
    return {
      cubes: [],
      totalGames: 0,
      message: 'No games matched the selected filters.',
    };
  }

  const versionMap = new Map();
  const gamesNeedingVersions = [];

  items.forEach((item) => {
    const gameId = item.$.objectid;
    const versionItem = item.version?.[0];
    const gameName = item.name?.[0]?._ || item.name?.[0] || `ID:${gameId}`;

    if (!versionItem || !versionItem.item || versionItem.item.length === 0) {
      if (!missingVersionGames.has(gameId)) {
        missingVersionGames.set(gameId, {
          id: gameId,
          name: gameName,
          versionsUrl: buildVersionsUrl(gameId, gameName),
        });
      }
    }

    if (versionItem && versionItem.item && versionItem.item.length > 0) {
      const versionId = versionItem.item[0].$?.id || 'default';
      const versionName = versionItem.item[0].name?.[0]?.$?.value || null;
      const width = versionItem.item[0].width?.[0]?.$?.value;
      const length = versionItem.item[0].length?.[0]?.$?.value;
      const depth = versionItem.item[0].depth?.[0]?.$?.value;

      const widthNum = Number.parseFloat(width);
      const lengthNum = Number.parseFloat(length);
      const depthNum = Number.parseFloat(depth);
      const hasValidDimensions = widthNum > 0 && lengthNum > 0 && depthNum > 0;

      if (hasValidDimensions) {
        const versionInfo = {
          id: versionId,
          name: versionName,
          yearPublished: versionItem.item[0].yearpublished?.[0]?.$?.value,
          width,
          length,
          depth,
        };
        const key = `${gameId}-${versionId}`;
        versionMap.set(key, versionInfo);
      } else {
        gamesNeedingVersions.push(gameId);
      }
    } else {
      gamesNeedingVersions.push(gameId);
    }
  });

  if (!bypassVersionWarning && missingVersionGames.size > 0) {
    const warningGames = Array.from(missingVersionGames.values()).sort((a, b) =>
      a.name.localeCompare(b.name),
    );
    const warningMessage = `${warningGames.length} game${
      warningGames.length !== 1 ? 's' : ''
    } do not have a specific BoardGameGeek version selected. Selecting a version helps ensure accurate dimensions.`;
    const secondaryMessage =
      'We can try to guess dimensions by checking the most recent English version first. This can take a while and may still require manual adjustments later.';

    progress(requestId, 'Missing game versions detected. Waiting for user confirmation...', {
      step: 'warning',
      warningType: 'missing_versions',
    });

    return {
      status: 'missing_versions',
      requestId,
      message: warningMessage,
      details: secondaryMessage,
      games: warningGames,
    };
  }

  const gameDetailsNeeded = new Map();

  items.forEach((item) => {
    const gameId = item.$.objectid;
    const versionId = item.version?.[0]?.item?.[0]?.$?.id || 'default';

    if (!gameDetailsNeeded.has(gameId)) {
      gameDetailsNeeded.set(gameId, []);
    }

    gameDetailsNeeded.get(gameId).push({
      collectionItem: item,
      versionId,
    });
  });

  const gameIds = Array.from(gameDetailsNeeded.keys());

  const gamesToFetch = [];
  const cachedGames = new Map();

  console.log(`üîç Checking cache for ${gameIds.length} games...`);
  progress(requestId, `Checking cache for ${gameIds.length} games...`, {
    step: 'games',
    total: gameIds.length,
  });
  for (const gameId of gameIds) {
    const cached = getGame(gameId);
    if (cached) {
      cachedGames.set(gameId, cached);
    } else {
      gamesToFetch.push(gameId);
    }
  }

  console.log(
    `   ‚úÖ ${cachedGames.size} games from cache, ${gamesToFetch.length} need fetching`,
  );
  progress(
    requestId,
    `Found ${cachedGames.size} games in cache, fetching ${gamesToFetch.length}...`,
    { step: 'games', cached: cachedGames.size, fetching: gamesToFetch.length },
  );

  const batchSize = 10;
  const allGames = [];

  for (let i = 0; i < gamesToFetch.length; i += batchSize) {
    const batch = gamesToFetch.slice(i, i + batchSize);
    const batchNum = Math.floor(i / batchSize) + 1;
    const totalBatches = Math.ceil(gamesToFetch.length / batchSize);
    console.log(`üì¶ Fetching batch ${batchNum}/${totalBatches} (${batch.length} games)`);
    progress(
      requestId,
      `Fetching game data: batch ${batchNum}/${totalBatches}`,
      {
        step: 'games',
        batch: batchNum,
        totalBatches,
        gamesInBatch: batch.length,
      },
    );

    const batchUnique = [...new Set(batch)];
    if (batchUnique.length < batch.length) {
      console.log(`   ‚ö†Ô∏è  Batch has ${batch.length - batchUnique.length} duplicate ID(s)`);
    }

    const thingParams = new URLSearchParams({
      id: batchUnique.join(','),
      stats: 1,
    });

    const thingResponse = await bggApiRequest(
      `${BGG_API_BASE}/thing?${thingParams.toString()}`,
      {
        headers: {
          Authorization: `Bearer ${BGG_API_TOKEN}`,
          Accept: 'application/xml',
        },
      },
    );

    const thingData = await parseBggXml(thingResponse.data);

    if (!thingData.items || !thingData.items.item) {
      continue;
    }

    const thingItems = Array.isArray(thingData.items.item)
      ? thingData.items.item
      : [thingData.items.item];

    for (const item of thingItems) {
      try {
        const gameId = item.$.id;

        const gameData = extractGameData(item);
        setGame(gameId, gameData);
        cachedGames.set(gameId, gameData);

        const versions = gameDetailsNeeded.get(gameId) || [];

        versions.forEach(({ versionId }) => {
          const key = `${gameId}-${versionId}`;
          const versionInfo = versionMap.get(key);
          const game = processGameItem(item, versionInfo, versionId);

          if (!game.versionName && versionInfo?.name) {
            game.versionName = versionInfo.name;
          }

          const missingVersionInfo = missingVersionGames.get(gameId);
          game.missingVersion = !!missingVersionInfo;
          if (missingVersionInfo) {
            game.versionsUrl = missingVersionInfo.versionsUrl;
          }

          const normalizedVersionId = extractVersionId(game, versionId);
          game.selectedVersionId = normalizedVersionId;
          if (!game.versionsUrl) {
            game.versionsUrl = buildVersionsUrl(
              gameId,
              item.name?.[0]?._ || item.name?.[0] || `ID:${gameId}`,
            );
          }
          game.usedAlternateVersionDims = false;
          game.correctionUrl = null;

          game.id = key;
          if (!game.baseGameId && game.isExpansion) {
            console.warn(`   ‚ö†Ô∏è  Expansion "${game.name}" (${game.id}) doesn't have baseGameId`);
          }

          allGames.push(game);
        });
      } catch (error) {
        console.error(`Error processing game ${item.$.id}:`, error.message);
      }
    }
  }

  for (const gameId of Array.from(cachedGames.keys())) {
    try {
      const gameData = cachedGames.get(gameId);

      if (gameData && (gameData._group !== undefined || '_group' in gameData)) {
        console.error(`   ‚ùå WARNING: Cached game data for ${gameId} has _group property!`);
        delete gameData._group;
      }

      const versions = gameDetailsNeeded.get(gameId) || [];

      versions.forEach(({ versionId }) => {
        const key = `${gameId}-${versionId}`;

        let dimensions = null;
        let versionName = null;
        const cachedVersion = getVersion(gameId, versionId);
        if (cachedVersion) {
          if (cachedVersion.dimensions && !cachedVersion.dimensions.missingDimensions) {
            dimensions = cachedVersion.dimensions;
          }
          if (cachedVersion.name) {
            versionName = cachedVersion.name;
          }
        }

        if (!dimensions) {
          const versionInfo = versionMap.get(key);
          if (versionInfo) {
            dimensions = {
              length: Number.parseFloat(versionInfo.length),
              width: Number.parseFloat(versionInfo.width),
              depth: Number.parseFloat(versionInfo.depth),
              missingDimensions: false,
            };
            if (!versionName && versionInfo.name) {
              versionName = versionInfo.name;
            }
          }
        }

        const fallbackVersionLabel =
          versionName ||
          gameData.versionName ||
          extractVersionLabelFromName(gameData.name) ||
          null;
        const game = {
          id: gameData.id,
          name: gameData.name,
          categories: gameData.categories,
          families: gameData.families,
          bggRank: gameData.bggRank,
          minPlayers: gameData.minPlayers,
          maxPlayers: gameData.maxPlayers,
          bestPlayerCount: gameData.bestPlayerCount,
          minPlaytime: gameData.minPlaytime,
          maxPlaytime: gameData.maxPlaytime,
          age: gameData.age,
          communityAge: gameData.communityAge,
          weight: gameData.weight,
          bggRating: gameData.bggRating,
          baseGameId: gameData.baseGameId || null,
          isExpansion: gameData.isExpansion || false,
          familyIds: gameData.familyIds || [],
          versionName: fallbackVersionLabel,
          dimensions:
            dimensions || {
              length: 0,
              width: 0,
              depth: 0,
              missingDimensions: true,
            },
        };
        if (!gameData.versionName && fallbackVersionLabel) {
          gameData.versionName = fallbackVersionLabel;
        }

        const missingVersionInfo = missingVersionGames.get(gameId);
        game.missingVersion = !!missingVersionInfo;
        if (missingVersionInfo) {
          game.versionsUrl = missingVersionInfo.versionsUrl;
        }

        game.id = key;

        const normalizedVersionId = extractVersionId(game, versionId);
        game.selectedVersionId = normalizedVersionId;
        if (!game.versionsUrl) {
          game.versionsUrl = buildVersionsUrl(gameId, game.name || `ID:${gameId}`);
        }
        game.usedAlternateVersionDims = false;
        game.correctionUrl = null;

        if (
          game.dimensions?.missingDimensions ||
          (game.dimensions.length === 0 &&
            game.dimensions.width === 0 &&
            game.dimensions.depth === 0)
        ) {
          const versionIdForCorrection = extractVersionId(game, versionId);
          if (versionIdForCorrection) {
            game.correctionUrl = buildCorrectionUrl(versionIdForCorrection);
          }
        }

        if (cachedVersion?.usedAlternateVersionDims) {
          game.usedAlternateVersionDims = true;
          const versionIdForCorrection = extractVersionId(game, versionId);
          if (versionIdForCorrection) {
            game.correctionUrl = buildCorrectionUrl(versionIdForCorrection);
          } else {
            game.correctionUrl = null;
          }
          console.log(
            `      ‚Ü∫ Using cached alternate-version dimensions for ${game.name} (version ${versionIdForCorrection || 'default'})`,
          );
        }

        if (game._group !== undefined || '_group' in game) {
          console.error(
            `   ‚ùå ERROR: Reconstructed game "${game.name}" (${game.id}) has _group property!`,
          );
          delete game._group;
        }
        if (game._groupId !== undefined || '_groupId' in game) {
          delete game._groupId;
        }

        allGames.push(game);
      });
    } catch (error) {
      console.error(`Error processing cached game ${gameId}:`, error.message);
    }
  }

  console.log(`‚úÖ Processed ${allGames.length} games`);
  progress(requestId, `Processed ${allGames.length} games`, {
    step: 'games',
    total: allGames.length,
  });

  const gamesNeedingFetch = [];
  for (const game of allGames) {
    if (
      game.dimensions.missingDimensions ||
      (game.dimensions.length === 0 &&
        game.dimensions.width === 0 &&
        game.dimensions.depth === 0)
    ) {
      if (game.baseGameId && game.id) {
        const parts = game.id.split('-');
        if (parts.length >= 2) {
          const versionId = parts[parts.length - 1];
          const cachedVersion = getVersion(game.baseGameId, versionId);
          if (cachedVersion && cachedVersion.dimensions && !cachedVersion.dimensions.missingDimensions) {
            game.dimensions = cachedVersion.dimensions;
            console.log(
              `      ‚úì Found dimensions in cache for ${game.name}: ${cachedVersion.dimensions.width}"√ó${cachedVersion.dimensions.length}"√ó${cachedVersion.dimensions.depth}"`,
            );
          } else {
            gamesNeedingFetch.push(game);
          }
        } else {
          gamesNeedingFetch.push(game);
        }
      } else {
        gamesNeedingFetch.push(game);
      }
    }
  }

  if (gamesNeedingFetch.length > 0) {
    console.log(`üìè Fetching dimensions for ${gamesNeedingFetch.length} games...`);
    progress(
      requestId,
      `Fetching dimensions for ${gamesNeedingFetch.length} games...`,
      { step: 'dimensions', count: gamesNeedingFetch.length },
    );

    const dimBatchSize = 5;
    for (let i = 0; i < gamesNeedingFetch.length; i += dimBatchSize) {
      const batch = gamesNeedingFetch.slice(i, i + dimBatchSize);
      const batchIds = batch.map((g) => g.baseGameId).filter(Boolean);

      if (batchIds.length === 0) continue;

      const dimBatchNum = Math.floor(i / dimBatchSize) + 1;
      const dimTotalBatches = Math.ceil(gamesNeedingFetch.length / dimBatchSize);
      console.log(`   üì¶ Dimension batch ${dimBatchNum}/${dimTotalBatches}`);
      progress(
        requestId,
        `Fetching dimensions: batch ${dimBatchNum}/${dimTotalBatches}`,
        { step: 'dimensions', batch: dimBatchNum, totalBatches: dimTotalBatches },
      );

      const versionParams = new URLSearchParams({
        id: batchIds.join(','),
        versions: 1,
      });

      try {
        const versionResponse = await bggApiRequest(
          `${BGG_API_BASE}/thing?${versionParams.toString()}`,
          {
            headers: {
              Authorization: `Bearer ${BGG_API_TOKEN}`,
              Accept: 'application/xml',
            },
          },
        );

        const versionData = await parseBggXml(versionResponse.data);

        if (versionData.items?.item) {
          const versionItems = Array.isArray(versionData.items.item)
            ? versionData.items.item
            : [versionData.items.item];

          versionItems.forEach((item) => {
            const gameId = item.$.id;
            const versions = item.versions?.[0]?.item || [];

            if (Array.isArray(versions)) {
              versions.forEach((versionItem) => {
                const versionInfo = extractVersionData(versionItem);
                if (versionInfo.versionId) {
                  setVersion(gameId, versionInfo.versionId, versionInfo);
                }
              });
            }

            const dimensions = findDimensionsFromVersions(item);

            batch.forEach((game) => {
              if (game.baseGameId === gameId) {
                if (game.baseGameId && game.id) {
                  const parts = game.id.split('-');
                  if (parts.length >= 2) {
                    const versionId = parts[parts.length - 1];

                    if (dimensions && !dimensions.missingDimensions) {
                      game.dimensions = dimensions;
                      console.log(
                        `      ‚úì Found dimensions for ${game.name}: ${dimensions.width}"√ó${dimensions.length}"√ó${dimensions.depth}"`,
                      );

                      const fallbackVersionLabel =
                        game.versionName || extractVersionLabelFromName(game.name) || null;
                      if (!game.versionName && fallbackVersionLabel) {
                        game.versionName = fallbackVersionLabel;
                      }
                      const versionDataToCache = {
                        versionId,
                        name: fallbackVersionLabel,
                        yearPublished: null,
                        dimensions,
                        usedAlternateVersionDims: !game.missingVersion,
                      };
                      setVersion(game.baseGameId, versionId, versionDataToCache);

                      if (!game.missingVersion) {
                        game.usedAlternateVersionDims = true;
                        const versionIdForCorrection = extractVersionId(game, versionId);
                        if (versionIdForCorrection) {
                          game.correctionUrl = buildCorrectionUrl(versionIdForCorrection);
                        } else {
                          game.correctionUrl = null;
                        }
                        console.log(
                          `      üîÑ Used alternate version dimensions for selected version of ${game.name} (version ${versionIdForCorrection || 'default'})`,
                        );
                      }
                    } else {
                      const fallbackVersionLabel =
                        game.versionName || extractVersionLabelFromName(game.name) || null;
                      if (!game.versionName && fallbackVersionLabel) {
                        game.versionName = fallbackVersionLabel;
                      }
                      const versionDataToCache = {
                        versionId,
                        name: fallbackVersionLabel,
                        yearPublished: null,
                        dimensions: DEFAULT_DIMENSIONS,
                        usedAlternateVersionDims: false,
                      };
                      setVersion(game.baseGameId, versionId, versionDataToCache);
                      game.usedAlternateVersionDims = false;
                      const versionIdForCorrection = extractVersionId(game, versionId);
                      if (versionIdForCorrection) {
                        game.correctionUrl = buildCorrectionUrl(versionIdForCorrection);
                      } else {
                        game.correctionUrl = null;
                      }
                    }
                  }
                }
              }
            });
          });
        }
      } catch (error) {
        console.error(`   ‚ùå Error fetching dimensions for batch: ${error.message}`);
      }
    }
  }

  let gamesWithDefaultDimensions = 0;
  allGames.forEach((game) => {
    if (
      game.dimensions.length === 0 &&
      game.dimensions.width === 0 &&
      game.dimensions.depth === 0
    ) {
      game.dimensions = { ...DEFAULT_DIMENSIONS };
      game.usedAlternateVersionDims = false;
      if (game.selectedVersionId) {
        game.correctionUrl = buildCorrectionUrl(game.selectedVersionId);
      } else {
        game.correctionUrl = null;
      }
      gamesWithDefaultDimensions += 1;

      if (game.baseGameId && game.id) {
        const parts = game.id.split('-');
        if (parts.length >= 2) {
          const versionId = parts[parts.length - 1];
          const fallbackVersionLabel =
            game.versionName || extractVersionLabelFromName(game.name) || null;
          if (!game.versionName && fallbackVersionLabel) {
            game.versionName = fallbackVersionLabel;
          }
          const versionDataToCache = {
            versionId,
            name: fallbackVersionLabel,
            yearPublished: null,
            dimensions: game.dimensions,
            usedAlternateVersionDims: false,
          };
          setVersion(game.baseGameId, versionId, versionDataToCache);
        }
      }
    }
  });

  if (gamesWithDefaultDimensions > 0) {
    console.log(
      `‚ö†Ô∏è  Applied default dimensions (12.8"√ó12.8"√ó1.8") to ${gamesWithDefaultDimensions} games`,
    );
  }

  if (!includeExpansionsFlag) {
    const beforeExpansionFilter = allGames.length;
    for (let i = allGames.length - 1; i >= 0; i -= 1) {
      const game = allGames[i];
      const allTags = [...(game.categories || []), ...(game.families || [])];
      const isExpansion = allTags.some(
        (tag) =>
          tag === 'Expansion for Base-game' ||
          tag.includes('Expansion for') ||
          tag.includes('expansion for'),
      );
      if (isExpansion) {
        allGames.splice(i, 1);
      }
    }

    if (beforeExpansionFilter > allGames.length) {
      console.log(
        `   ‚Üí Filtered ${beforeExpansionFilter - allGames.length} expansions after full data fetch`,
      );
    }
  }

  const uniqueGames = [];
  const seenIds = new Set();

  for (const game of allGames) {
    if (!seenIds.has(game.id)) {
      uniqueGames.push(game);
      seenIds.add(game.id);
    } else {
      console.log(`   ‚ö†Ô∏è  Removing processing duplicate: ${game.name} (ID: ${game.id})`);
    }
  }

  console.log(
    `   ‚ÑπÔ∏è  Total items to pack: ${uniqueGames.length} (includes multiple versions of same games)`,
  );

  const excludedIdsSet = new Set(
    Array.isArray(overridesPayload.excludedVersions)
      ? overridesPayload.excludedVersions
          .map((item) => `${item.game}-${item.version}`)
          .filter(Boolean)
      : [],
  );

  const orientationOverrideMap = new Map(
    Array.isArray(overridesPayload.stackingOverrides)
      ? overridesPayload.stackingOverrides
          .filter(
            (item) =>
              Number.isInteger(item?.game) &&
              Number.isInteger(item?.version) &&
              (item.orientation === 'vertical' || item.orientation === 'horizontal'),
          )
          .map((item) => [`${item.game}-${item.version}`, item.orientation])
      : [],
  );

  const dimensionOverrideMap = new Map(
    Array.isArray(overridesPayload.dimensionOverrides)
      ? overridesPayload.dimensionOverrides
          .filter((item) => {
            if (!Number.isInteger(item?.game) || !Number.isInteger(item?.version)) {
              return false;
            }
            const length = Number(item.length);
            const width = Number(item.width);
            const depth = Number(item.depth ?? item.height);
            return (
              Number.isFinite(length) &&
              Number.isFinite(width) &&
              Number.isFinite(depth) &&
              length > 0 &&
              width > 0 &&
              depth > 0
            );
          })
          .map((item) => [
            `${item.game}-${item.version}`,
            {
              length: Number(item.length),
              width: Number(item.width),
              depth: Number(item.depth ?? item.height),
            },
          ])
      : [],
  );

  if (excludedIdsSet.size > 0) {
    console.log(
      `   üö´ Excluding ${excludedIdsSet.size} game(s) from packing due to user override`,
    );
  }
  if (orientationOverrideMap.size > 0) {
    console.log(
      `   ‚ÜïÔ∏è  Applying forced orientation to ${orientationOverrideMap.size} game(s)`,
    );
  }
  if (dimensionOverrideMap.size > 0) {
    console.log(
      `   üìè Applying manual dimensions to ${dimensionOverrideMap.size} game(s)`,
    );
  }

  const preparedGames = uniqueGames
    .filter((game) => !excludedIdsSet.has(game.id))
    .map((game) => {
      const originalDimensions = {
        length: game.dimensions?.length ?? 0,
        width: game.dimensions?.width ?? 0,
        depth: game.dimensions?.depth ?? 0,
        missingDimensions: game.dimensions?.missingDimensions ?? false,
      };

      const overrideDims = dimensionOverrideMap.get(game.id);
      if (overrideDims) {
        game.bggDimensions = { ...originalDimensions };
        game.userDimensions = { ...overrideDims };
        game.dimensions = {
          length: overrideDims.length,
          width: overrideDims.width,
          depth: overrideDims.depth,
          missingDimensions: originalDimensions.missingDimensions,
        };
      } else {
        game.bggDimensions = { ...originalDimensions };
        game.userDimensions = null;
      }

      const forcedOrientation = orientationOverrideMap.get(game.id);
      if (forcedOrientation) {
        game.forcedOrientation = forcedOrientation;
      } else {
        delete game.forcedOrientation;
      }

      return game;
    });

  if (preparedGames.length < uniqueGames.length) {
    console.log(
      `   ‚Üí ${uniqueGames.length - preparedGames.length} game(s) removed via manual exclusions`,
    );
  }

  const gamesToPack = preparedGames;

  versionMap.clear();
  items.length = 0;
  allGames.length = 0;

  if (global.gc) {
    console.log('   üóëÔ∏è  Running garbage collection...');
    global.gc();
  }

  progress(requestId, `Packing ${gamesToPack.length} games into cubes...`, {
    step: 'packing',
    gameCount: gamesToPack.length,
  });

  const shouldGroupExpansions =
    !optimizeSpaceFlag && groupExpansionsFlag && includeExpansionsFlag;
  const shouldGroupSeries = !optimizeSpaceFlag && groupSeriesFlag;

  if (optimizeSpaceFlag && (groupExpansionsFlag || groupSeriesFlag)) {
    console.log('   ‚ÑπÔ∏è  Optimize for space enabled ‚Äì grouping options disabled for this run');
  }

  const { cubes: packedCubes, oversizedExcludedGames } = packGamesIntoCubes(
    gamesToPack,
    sortRules,
    stacking,
    lockRotationFlag,
    optimizeSpaceFlag,
    respectSortOrderFlag,
    fitOversizedFlag,
    shouldGroupExpansions,
    shouldGroupSeries,
  );

  progress(requestId, `Complete! Packed into ${packedCubes.length} cubes`, {
    step: 'complete',
    cubes: packedCubes.length,
    games: gamesToPack.length,
  });

  console.log('   üîç Deep circular reference check before serialization...');
  console.log(`   Checking ${packedCubes.length} cubes...`);

  const cleanCubes = [];
  let gameCount = 0;

  for (let cubeIdx = 0; cubeIdx < packedCubes.length; cubeIdx += 1) {
    const cube = packedCubes[cubeIdx];
    const cleanCube = {
      id: cube.id,
      currentHeight: cube.currentHeight,
      currentWidth: cube.currentWidth,
      rows: [],
      games: [],
    };

    for (const row of cube.rows || []) {
      const cleanRow = {
        heightUsed: row.heightUsed,
        widthUsed: row.widthUsed,
        games: [],
      };

      for (const game of row.games || []) {
        gameCount += 1;
        const versionLabel =
          game.versionName || extractVersionLabelFromName(game.name) || null;
        const cleanGame = {
          id: game.id,
          name: game.name,
          dimensions: game.dimensions ? { ...game.dimensions } : game.dimensions,
          position: game.position ? { ...game.position } : game.position,
          packedDims: game.packedDims ? { ...game.packedDims } : game.packedDims,
          actualDims: game.actualDims ? { ...game.actualDims } : game.actualDims,
          orientedDims: game.orientedDims ? { ...game.orientedDims } : game.orientedDims,
          actualOrientedDims: game.actualOrientedDims
            ? { ...game.actualOrientedDims }
            : game.actualOrientedDims,
          oversizedX: game.oversizedX,
          oversizedY: game.oversizedY,
          categories: game.categories ? [...(game.categories || [])] : [],
          families: game.families ? [...(game.families || [])] : [],
          bggRank: game.bggRank,
          minPlayers: game.minPlayers,
          maxPlayers: game.maxPlayers,
          bestPlayerCount: game.bestPlayerCount,
          minPlaytime: game.minPlaytime,
          maxPlaytime: game.maxPlaytime,
          age: game.age,
          communityAge: game.communityAge,
          weight: game.weight,
          bggRating: game.bggRating,
          baseGameId: game.baseGameId,
          isExpansion: game.isExpansion,
          familyIds: game.familyIds ? [...(game.familyIds || [])] : [],
          missingVersion: !!game.missingVersion,
          versionsUrl: game.versionsUrl || null,
          usedAlternateVersionDims: !!game.usedAlternateVersionDims,
          versionName: versionLabel,
          correctionUrl: game.correctionUrl || null,
          selectedVersionId: game.selectedVersionId || null,
        };
        cleanGame.bggDimensions = game.bggDimensions ? { ...game.bggDimensions } : null;
        cleanGame.userDimensions = game.userDimensions ? { ...game.userDimensions } : null;
        cleanGame.forcedOrientation = game.forcedOrientation || null;
        cleanGame.appliedOrientation = game.appliedOrientation || null;

        cleanRow.games.push(cleanGame);
      }

      cleanCube.rows.push(cleanRow);
    }

    for (const game of cube.games || []) {
      const versionLabel =
        game.versionName || extractVersionLabelFromName(game.name) || null;
      const cleanGame = {
        id: game.id,
        name: game.name,
        dimensions: game.dimensions ? { ...game.dimensions } : game.dimensions,
        position: game.position ? { ...game.position } : game.position,
        packedDims: game.packedDims ? { ...game.packedDims } : game.packedDims,
        actualDims: game.actualDims ? { ...game.actualDims } : game.actualDims,
        orientedDims: game.orientedDims ? { ...game.orientedDims } : game.orientedDims,
        actualOrientedDims: game.actualOrientedDims
          ? { ...game.actualOrientedDims }
          : game.actualOrientedDims,
        oversizedX: game.oversizedX,
        oversizedY: game.oversizedY,
        categories: game.categories ? [...(game.categories || [])] : [],
        families: game.families ? [...(game.families || [])] : [],
        bggRank: game.bggRank,
        minPlayers: game.minPlayers,
        maxPlayers: game.maxPlayers,
        bestPlayerCount: game.bestPlayerCount,
        minPlaytime: game.minPlaytime,
        maxPlaytime: game.maxPlaytime,
        age: game.age,
        communityAge: game.communityAge,
        weight: game.weight,
        bggRating: game.bggRating,
        baseGameId: game.baseGameId,
        isExpansion: game.isExpansion,
        familyIds: game.familyIds ? [...(game.familyIds || [])] : [],
        missingVersion: !!game.missingVersion,
        versionsUrl: game.versionsUrl || null,
        usedAlternateVersionDims: !!game.usedAlternateVersionDims,
        versionName: versionLabel,
        correctionUrl: game.correctionUrl || null,
        selectedVersionId: game.selectedVersionId || null,
      };
      cleanCube.games.push(cleanGame);
    }

    cleanCubes.push(cleanCube);
  }

  console.log(`   ‚úÖ Clean copies created for ${gameCount} games in ${cleanCubes.length} cubes`);
  console.log('   üì§ Attempting JSON serialization...');

  const stats = calculateStatsSummary(cleanCubes, stacking);

  const dimensionSummary = {
    guessedVersionCount: 0,
    selectedVersionFallbackCount: 0,
    missingDimensionCount: 0,
    exceedingCapacityCount: 0,
  };

  for (const cube of cleanCubes) {
    for (const game of cube.games) {
      if (game.missingVersion) {
        dimensionSummary.guessedVersionCount += 1;
      }
      if (game.usedAlternateVersionDims) {
        dimensionSummary.selectedVersionFallbackCount += 1;
      }
      if (game.dimensions?.missingDimensions) {
        dimensionSummary.missingDimensionCount += 1;
      }
      if (game.oversizedX || game.oversizedY) {
        dimensionSummary.exceedingCapacityCount += 1;
      }
    }
  }

  console.log('   ‚ÑπÔ∏è Dimension summary:', dimensionSummary);

  const oversizedStuffedGames = getOversizedStuffedGames(cleanCubes);
  const oversizedGames = [
    ...oversizedStuffedGames,
    ...(Array.isArray(oversizedExcludedGames) ? oversizedExcludedGames : []),
  ];

  return {
    cubes: cleanCubes,
    totalGames: gamesToPack.length,
    stats,
    dimensionSummary,
    oversizedGames,
  };
};

